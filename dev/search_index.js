var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Wahoo.track","page":"API","title":"Wahoo.track","text":"Tracks the location of the fish\n\ntrack(;pos_init::Matrix,\n       tsave::AbstractVector = 1:100,\n       bathymetry::GeoArrays.GeoArray,\n       observations::Vector,\n       observation_models::Vector{Function},\n       sensor_positions::Vector,\n       spatial_resolution,\n       movement_std,\n       smoother::Bool = true,\n       filter::Bool = false,\n       n_trajectories::Int = 0,\n       show_progressbar::Bool = !is_logging(stderr),\n       precision = Float32)\n\nInfers the location of the animal based on a diffusion model and smoothing.\n\nKeyword Arguments\n\npos_init::Matrix: Initial probability distribution of the fish position\ntsave::AbstractVector: Time steps at which the probability map is saved.\nbathymetry: Bathymetric data as GeoArray\nspatial_resolution: the spatial resolution [m] of the bathymetry.\nmovement_std: Standard deviation of the fish movement within one time step [m]\nobservations: Vector holding all observations. Each element contains the observation of a separate sensor.\nobservation_models::Vector{Function}: Vector containing the observation model for each sensor.\nsensor_positions: Vector of tuples of coordinates or nothing, i.e. Vector{Union{Nothing, Tuple{Real, Real}}}\nsmoother = true: if true the probabilities from the smoother run are returned.\nfilter = false: if true the probabilities from the filter run are returned.\nn_trajectories = 0: Number of trajectories to sample\nshow_progressbar = !is_logging(stderr): defaults to true for interactive use.\nprecision = Float32: numerical floating point type used for computations\n\nNote, the elements of the vectors observations, observation_models, and sensor_positions must be sorted in the same way, i.e. the elements at the same position in the Vectors refer to the same sensor.\n\nReturn\n\nA named tuple with the following elements:\n\nlog_p: Log probability of the observations, log p(y_{1...T}).\ntsave: Vector of time steps at which the results are saved.\ntrajectories: Sampled trajectories if n_trajectories > 0, otherwise nothing.\n\nAdditionally, if smoother = true:\n\npos_smoother: Prob(st | y{1...T}), the smoothed probability distribution of the fish positions for all timesteps in tsave.\nresidence_dist: Residence distribution, 1/T Σ Prob(st | y{1...T}).\n\nAdditionally, if filter = true:\n\npos_filter: Prob(st | y{1...t}), the filtered probability distribution of the fish positions.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Installation","page":"Manual","title":"Installation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Install Julia, at least version 1.9. If you plan to use GPU support, it is advisable to use the latest stable version.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Within Julia install Wahoo:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"] Wahoo","category":"page"},{"location":"manual/#Defining-observation-models","page":"Manual","title":"Defining observation models","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The user must define an observation model for every sensor. This is a function that computes the probability (density) of the observed signal given the location, p(y_t | s_t).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The function must have the following signature:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":" p_obs(signals, t::Int, bathymetry_depth::Number, dist::Number)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"where bathymetry_depth is the water depth at s_t and dist is the Euclidean distance from s_t to the sensor location. Note, the function must accept all four arguments, even if some are not used.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that if GPU use is planned, the function must be type-stable!","category":"page"},{"location":"manual/#Using-GPU","page":"Manual","title":"Using GPU","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To use the GPU for computations, the packages CUDA.jl and cuDNN.jl must be imported. Currently, only CUDA-compatible GPUs are supported.","category":"page"},{"location":"manual/#Export-results","page":"Manual","title":"Export results","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The results can be exported in different ways. We recommend hdf5 if interoperability is required or JLD2  for postprocessing in Julia.","category":"page"},{"location":"manual/#HDF5","page":"Manual","title":"HDF5","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"HDF5 is a generic format for array like data that can be read from most languages. The function below exports the result of track as hdf5. Note, you must install HDF5.jl additionally to Wahoo.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"import HDF5\n\n\"\"\"\nWrite the result from `Wahoo.track()` to `file` in the hdf5 format.\n\"\"\"\nfunction export_hdf5(res, file)\n\n    # Open (and create) the HDF5 file in write mode\n    HDF5.h5open(file, \"w\") do f\n\n        # --- model outputs\n        write(f, \"timesteps\", collect(res.tsave))\n\n        f[\"pos\", compress=3] =  dropdims(res.pos_smoother, dims=3)\n        HDF5.attributes(f[\"pos\"])[\"dimensions\"] = \"(y_coord, x_coord, timestep) of size $(size(res.pos_smoother))\"\n\n        f[\"residence_distribution\", compress=3] = res.residence_dist\n        HDF5.attributes(f[\"residence_distribution\"])[\"dimensions\"] = \"(y_coord, x_coord) of size $(size(res.residence_dist))\"\n\n        if isdefined(res, :pos_filter)\n            f[\"pos_filtered\", compress=3] =  dropdims(res.pos_filter, dims=3)\n            HDF5.attributes(f[\"pos_filtered\"])[\"dimensions\"] = \"(y_coord, x_coord, timestep) of size $(size(res.pos_filter))\"\n        end\n\n        write(f, \"log_p\", res.log_p)\n\n        if !isnothing(res.trajectories)\n            # Create a group for the 'trajectories' data\n            grp = HDF5.create_group(f, \"trajectories\")\n            HDF5.attributes(f[\"trajectories\"])[\"description\"] = \"Each trajectory is a 2d array of shape (2 x time).\" *\n                                                                \" Note, it contains all time steps, i.e. from 1:maximum(timesteps).\" *\n                                                                \" The first row are the y-coordinates, the second the x-coordinates.\"\n\n            # Write each matrix in the track array as its own dataset\n            for (i, tr) in enumerate(res.trajectories)\n                write(grp, \"traj$(i)\", tr)\n            end\n        end\n    end\nend","category":"page"},{"location":"manual/#Read-HDF5-with-Python","page":"Manual","title":"Read HDF5 with Python","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The code below gives an example of how the data can be read with Python. Note, the order of the indices differs.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"# /// script\n# dependencies = [\n#   \"h5py\",\n#   \"numpy\"\n# ]\n# ///\n\nimport h5py\nimport numpy as np\n\n# -------\n# load data from hdf5 file\n\nwith h5py.File('Wahoo_results.hdf5', 'r') as f:\n    print(\"structure of the file:\")\n    print(f.keys())\n    print(f['trajectories'].keys())\n\n    pos = f['pos'][:]\n    timesteps = f['timesteps'][:]\n    trajectories_group = f['trajectories']\n    trajectories = [trajectories_group[key][:] for key in trajectories_group.keys()]\n\n    residence_distribution = f['residence_distribution'][:]\n\n\nprint('\\nProbabilities of the fish position, saved at `timesteps`:')\nprint('shape (time, x, y):', np.shape(pos))\n# For example, pos[:,:,2] is the distribution of the position for at time = timesteps[2]\n\nprint('\\nAll trajectories:')\nfor i, arr in enumerate(trajectories, start=1):\n    print(f\" - trajectory {i} shape: {np.shape(arr)}\")\n# For example, trajectories[1][2] is the position for time = 3","category":"page"},{"location":"manual/#JLD2","page":"Manual","title":"JLD2","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"JLD2 saves and loads Julia data structures in a format comprising a subset of HDF5. It is the recommended format if the data will be used by another Julia script. Note, JLD2.jl and CodecZlib.jl must be installed additionally to Wahoo.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The function below stores the inference results together with the corresponding inputs.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"import JLD2\nimport CodecZlib                # for compression\n\nfunction export_jld2(res, file; bathymetry, spatial_resolution,\n                     acoustic_obs, acoustic_pos, depth_obs)\n\n    # Open (and create) the JLD2 file in write mode\n    JLD2.jldopen(file, \"w\"; compress = true) do f\n\n        # --- model inputs\n        f[\"bathymetry\"] = bathymetry\n        f[\"acoustic_obs\"] = acoustic_obs\n        f[\"acoustic_pos\"] = acoustic_pos\n        f[\"depth_obs\"] = depth_obs\n        f[\"spatial_resolution\"] = spatial_resolution\n\n        # --- model outputs\n        f[\"timesteps\"] = collect(res.tsave)\n        f[\"pos\"] = res.pos_smoother\n        f[\"residence_distribution\"] = res.residence_dist\n        f[\"log_p\"] = res.log_p\n\n        if isdefined(res, :pos_filter)\n            f[\"pos_filtered\"] =  res.pos_filter\n        end\n\n        if !isnothing(res.trajectories)\n            f[\"trajectories\"] = res.trajectories\n        end\n    end\n    file\nend","category":"page"},{"location":"manual/#Visualizations","page":"Manual","title":"Visualizations","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"todo","category":"page"},{"location":"internal/#Implementation-Details","page":"Internals","title":"Implementation Details","text":"","category":"section"},{"location":"internal/","page":"Internals","title":"Internals","text":"The equations given by Thygesen et al. (2009) are relatively straight-forward to implement. Most complications stem from the fact that we cannot store the probability maps for every time-step due to memory constrains (in particular on the GPU).","category":"page"},{"location":"internal/","page":"Internals","title":"Internals","text":"The figure below illustrates how the caching works on the high-level.","category":"page"},{"location":"internal/","page":"Internals","title":"Internals","text":"(Image: compute flow)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Wahoo.","category":"page"},{"location":"#Wahoo.jl","page":"Home","title":"Wahoo.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Wahoo is a package designed for tracking the movement of marine animals using probabilistic state-space models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/smoothing_animated.gif\" style=\"width: 75%; height: auto;\" />","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The filter and smoother implementation is based on:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thygesen, Uffe Høgsbro, Martin Wæver Pedersen, and Henrik Madsen. 2009. “Geolocating Fish Using Hidden Markov Models and Data Storage Tags.” In Tagging and Tracking of Marine Animals with Electronic Devices, 277–93. Dordrecht: Springer Netherlands. https://doi.org/10.1007/978-1-4020-9640-2_17.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The example bathymetry data is derived from the following survey:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Howe JA, Anderton R, Arosio R, et al. The seabed geomorphology and geological structure of the Firth of Lorn, western Scotland, UK, as revealed by multibeam echo-sounder survey. Earth and Environmental Science Transactions of the Royal Society of Edinburgh. 2014;105(4):273-284. doi:10.1017/S1755691015000146","category":"page"},{"location":"","page":"Home","title":"Home","text":"For an alternative, particle-based implementation see:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lavender, E., Scheidegger, A., Albert, C., Biber, S.W., Illian, J., Thorburn, J., Smout, S., Moor, H., 2025. patter: Particle algorithms for animal tracking in R and Julia. Methods in Ecology and Evolution. https://doi.org/10.1111/2041-210X.70029.","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The following example uses example data that come with Wahoo.jl.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Wahoo\n\nimport GeoArrays\nusing DelimitedFiles: readdlm\n\n# This is optional. If *both* packages are imported,\n# some computations use the GPU. Otherwise, the CPU is used for everything.\nimport CUDA\nimport cuDNN","category":"page"},{"location":"example/#1)-Bathymetry","page":"Example","title":"1) Bathymetry","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Load the bathymetry map which provides depth information for each grid cell.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"pathdata = joinpath(pkgdir(Wahoo), \"example_data\")\nbathymetry_map = GeoArrays.read(joinpath(pathdata, \"bathymetry_200m.tif\"))\nGeoArrays.bbox(bathymetry_map)","category":"page"},{"location":"example/#2)-Depth-observations","page":"Example","title":"2) Depth observations","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Read the depth measurements and define the exponential likelihood model. This model implies the fish is more likely close to the seabed.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# read depth signals\ndepth_signals = readdlm(joinpath(pathdata, \"depth_observations.csv\"), ',', header=true)[1][:,2]\n\n# define likelihood\nfunction p_obs_depth_exponential(signals, t, waterdepth, dist; scale=30f0)\n    signal = signals[t]\n    if signal > waterdepth         # water is too shallow\n        return zero(waterdepth)\n    else\n        # exponential\n        Z = 1 - exp(-waterdepth/scale) # normalisation due to truncation\n        exp(-(waterdepth - signal)/scale)/(scale * Z)\n    end\nend","category":"page"},{"location":"example/#3)-Acoustic-observations","page":"Example","title":"3) Acoustic observations","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Load acoustic detection data and specify the probability model for acoustic signals given the distance.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# read acoustic signals\nacoustic_signals = readdlm(joinpath(pathdata, \"acoustic_observations.csv\"), ',', header=true)[1][:,2:3]\nacoustic_signals = Int.(acoustic_signals')\nacoustic_obs = [acoustic_signals[1,:], acoustic_signals[2,:]]\n\n# read sensor positions\nmoorings = readdlm(joinpath(pathdata, \"acoustic_moorings.csv\"), ',', header=true)[1]\nacoustic_pos = tuple.(moorings[:,2], moorings[:,3])\n\n# define likelihood\nfunction p_obs_acoustic(signals, t::Int, depth::Number, distance::Number)\n    Wahoo.p_acoustic_sigmoid(signals[t], depth, distance)\nend\n\nacoustic_obs_models = [p_obs_acoustic, p_obs_acoustic]","category":"page"},{"location":"example/#4)-Define-parameters","page":"Example","title":"4) Define parameters","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"We define the initial distribution of the fish location and configure the model parameters such as time steps, movement capabilities of the fish, and spatial resolution of the bathymetry.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"\n# initial values: Matrix{Float64}\np0 = zeros(size(bathymetry_map)[1], size(bathymetry_map)[2])\nidx = GeoArrays.indices(bathymetry_map, (709757.111649658, 6.26772603565296e6)) # last known location of the fish\np0[idx] = 1\n\ntsave = 1:2:720             # time steps to save\nmovement_std = 100          # standard deviation of the fish movement for one time step [m]\nspatial_resolution = 200    # spatial resolution [m]","category":"page"},{"location":"example/#5)-Run-inference","page":"Example","title":"5) Run inference","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Finally, we run the model inference, combining all observations and assumptions.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"res = track(pos_init = p0, bathymetry = bathymetry_map,\n            tsave = tsave,\n            spatial_resolution = spatial_resolution,\n            movement_std = movement_std,\n            observations = [depth_signals, acoustic_obs...],\n            observation_models = [p_obs_depth_exponential, acoustic_obs_models...],\n            sensor_positions = [nothing, acoustic_pos...],\n            n_trajectories = 2)\n\n# Resulting probabilities\n# Array{Float32, 4}: Ny × Nx × 1 × time\nres.pos_smoother     # Prob(s_t | y_{1...T}), only if `smoother = true` was used\nres.pos_filter       # Prob(s_t | y_{1...t}), only if `filter = true`\nres.residence_dist   # 1/T Σ Prob(s_t | y_{1...T})\nres.trajectories     # Vector of trajectories sampled from Prob(s_{1...T} | y_{1...T})\nres.log_p            # Prob(y_t)\nres.tsave            # time points","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The result of the smoother res.pos_smoother can be visualized:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"<img src=\"../assets/smoothing_animated.gif\" style=\"width: 75%; height: auto;\" />","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Note, the code for visualization is not part of Wahoo.","category":"page"}]
}
