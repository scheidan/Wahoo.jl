var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Wahoo.track","page":"API","title":"Wahoo.track","text":"Tracks the location of the fish\n\ntrack(;pos_init::Matrix,\n       tsave::AbstractVector = 1:100,\n       bathymetry::GeoArrays.GeoArray,\n       observations::Vector,\n       observation_models::Vector{Function},\n       sensor_positions::Vector,\n       spatial_resolution,\n       movement_std,\n       save_filter::Bool = false,\n       n_trajectories::Int = 0,\n       show_progressbar::Bool = !is_logging(stderr),\n       precision = Float32)\n\nInfers the location of the animal based on a diffusion model and smoothing.\n\nKeyword Arguments\n\npos_init::Matrix: Initial probability distribution of the fish position\ntsave::AbstractVector: Time steps at which the probability map is saved.\nbathymetry: Bathymetric data as GeoArray\nspatial_resolution: the spatial resolution [m] of the bathymetry.\nmovement_std: Standard deviation of the fish movement within one time step [m]\nobservations: Vector holding all observations. Each element contains the observation of a separate sensor.\nobservation_models::Vector{Function}: Vector containing the observation model for each sensor.\nsensor_positions: Vector of tuples of coordinates or nothing, i.e. Vector{Union{Nothing, Tuple{Real, Real}}}\nsave_filter: if true the probabilities from the filter run are returned.\nn_trajectories=0: Number of trajectories to sample\nshow_progressbar = !is_logging(stderr): defaults to true for interactive use.\nprecision = Float32: numerical floating point type used for computations\n\nNote, the elements of the vectors observations, observation_models, and sensor_positions must be sorted in the same way, i.e. the elements at the same position in the Vectors refer to the same sensor.\n\nReturn\n\nA named tuple with the following elements:\n\npos_smoother: Smoothed probability distribution of the fish positions for all timesteps in tsave.\nresidence_dist: Residence distribution.\ntrajectories: Sampled trajectories if n_trajectories > 0, otherwise nothing.\nlog_p: Log probability of the observations.\ntsave: Vector of time steps at which the results are saved.\npos_filter: Filtered  probability distribution of the fish positions, included if save_filter = true.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Installation","page":"Manual","title":"Installation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Install Julia, at least version 1.9. If you plan to use GPU support, it is advisable to use the latest stable version.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Within Julia install Wahoo:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"] Wahoo","category":"page"},{"location":"manual/#Defining-observation-models","page":"Manual","title":"Defining observation models","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The user must define an observation model for every sensor. This is a function that computes the probability (density) of the observed signal given the location, p(y_t | s_t).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The function must have the following signature:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":" p_obs(signals, t::Int, bathymetry_depth::Number, dist::Number)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"where bathymetry_depth is the water depth at s_t and dist is the Euclidean distance from s_t to the sensor location. Note, the function must accept all four arguments, even if some are not used.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that if GPU use is planned, the function must be type-stable!","category":"page"},{"location":"manual/#Using-GPU","page":"Manual","title":"Using GPU","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To use the GPU for computations, the packages CUDA.jl and cuDNN.jl must be imported. Currently, only CUDA-compatible GPUs are supported.","category":"page"},{"location":"manual/#Export-results","page":"Manual","title":"Export results","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"todo","category":"page"},{"location":"manual/#Visualizations","page":"Manual","title":"Visualizations","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"todo","category":"page"},{"location":"internal/#Implementation-Details","page":"Internals","title":"Implementation Details","text":"","category":"section"},{"location":"internal/","page":"Internals","title":"Internals","text":"The equations given by Thygesen et al. (2009) are relatively straight-forward to implement. Most complications stem from the fact that we cannot store the probability maps for every time-step due to memory constrains (in particular on the GPU).","category":"page"},{"location":"internal/","page":"Internals","title":"Internals","text":"The figure below illustrates how the caching works on the high-level.","category":"page"},{"location":"internal/","page":"Internals","title":"Internals","text":"(Image: compute flow)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Wahoo.","category":"page"},{"location":"#Wahoo.jl","page":"Home","title":"Wahoo.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Wahoo is a package designed for tracking the movement of marine animals using probabilistic state-space models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/smoothing_animated.gif\" style=\"width: 75%; height: auto;\" />","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The filter and smoother implementation is based on:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thygesen, Uffe Høgsbro, Martin Wæver Pedersen, and Henrik Madsen. 2009. “Geolocating Fish Using Hidden Markov Models and Data Storage Tags.” In Tagging and Tracking of Marine Animals with Electronic Devices, 277–93. Dordrecht: Springer Netherlands. https://doi.org/10.1007/978-1-4020-9640-2_17.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The example bathymetry data is derived from the following survey:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Howe JA, Anderton R, Arosio R, et al. The seabed geomorphology and geological structure of the Firth of Lorn, western Scotland, UK, as revealed by multibeam echo-sounder survey. Earth and Environmental Science Transactions of the Royal Society of Edinburgh. 2014;105(4):273-284. doi:10.1017/S1755691015000146","category":"page"},{"location":"","page":"Home","title":"Home","text":"For an alternative, particle-based implementation see:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lavender, E., Scheidegger, A., Albert, C., Biber, S.W., Illian, J., Thorburn, J., Smout, S., Moor, H., 2025. patter: Particle algorithms for animal tracking in R and Julia. Methods in Ecology and Evolution. https://doi.org/10.1111/2041-210X.70029.","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The following example uses example data that come with Wahoo.jl.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Wahoo\n\nimport GeoArrays\nusing DelimitedFiles: readdlm\n\n# This is optional. If *both* packages are imported,\n# some computations use the GPU. Otherwise, the CPU is used for everything.\nimport CUDA\nimport cuDNN","category":"page"},{"location":"example/#1)-Bathymetry","page":"Example","title":"1) Bathymetry","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Load the bathymetry map which provides depth information for each grid cell.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"pathdata = joinpath(pkgdir(Wahoo), \"example_data\")\nbathymetry_map = GeoArrays.read(joinpath(pathdata, \"bathymetry_200m.tif\"))\nGeoArrays.bbox(bathymetry_map)","category":"page"},{"location":"example/#2)-Depth-observations","page":"Example","title":"2) Depth observations","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Read the depth measurements and define the exponential likelihood model. This model implies the fish is more likely close to the seabed.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# read depth signals\ndepth_signals = readdlm(joinpath(pathdata, \"depth_observations.csv\"), ',', header=true)[1][:,2]\n\n# define likelihood\nfunction p_obs_depth_exponential(signals, t, waterdepth, dist; scale=30f0)\n    signal = signals[t]\n    if signal > waterdepth         # water is too shallow\n        return zero(waterdepth)\n    else\n        # exponential\n        Z = 1 - exp(-waterdepth/scale) # normalisation due to truncation\n        exp(-(waterdepth - signal)/scale)/(scale * Z)\n    end\nend","category":"page"},{"location":"example/#3)-Acoustic-observations","page":"Example","title":"3) Acoustic observations","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Load acoustic detection data and specify the probability model for acoustic signals given the distance.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# read acoustic signals\nacoustic_signals = readdlm(joinpath(pathdata, \"acoustic_observations.csv\"), ',', header=true)[1][:,2:3]\nacoustic_signals = Int.(acoustic_signals')\nacoustic_obs = [acoustic_signals[1,:], acoustic_signals[2,:]]\n\n# read sensor positions\nmoorings = readdlm(joinpath(pathdata, \"acoustic_moorings.csv\"), ',', header=true)[1]\nacoustic_pos = tuple.(moorings[:,2], moorings[:,3])\n\n# define likelihood\nfunction p_obs_acoustic(signals, t::Int, depth::Number, distance::Number)\n    Wahoo.p_acoustic_sigmoid(signals[t], depth, distance)\nend","category":"page"},{"location":"example/#4)-Define-parameters","page":"Example","title":"4) Define parameters","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"We define initial distribution of the fish location and configures the model parameters such as time steps, movement capabilities of the fish, and spatial resolution of the bathymetry.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"\n# initial values: Matrix{Float64}\np0 = zeros(size(bathymetry_map)[1], size(bathymetry_map)[2])\nidx = GeoArrays.indices(bathymetry_map, (709757.111649658, 6.26772603565296e6)) # last known location of the fish\np0[idx] = 1\n\ntsave = 1:2:720             # time steps to save\nmovement_std = 100          # standard deviation of the fish movement for one time step [m]\nspatial_resolution = 200    # spatial resolution [m]","category":"page"},{"location":"example/#5)-Run-inference","page":"Example","title":"5) Run inference","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Finally, we run the model inference combine all observations and assumptions.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"res = track(pos_init = p0, bathymetry = bathymetry_map,\n            tsave = tsave,\n            spatial_resolution = spatial_resolution,\n            movement_std = movement_std,\n            observations = [depth_signals, acoustic_obs...],\n            observation_models = [p_obs_depth_exponential, acoustic_obs_models...],\n            sensor_positions = [nothing, acoustic_pos...],\n            n_trajectories = 2)\n\n# Resulting probabilities\n# Array{Float32, 4}: Ny × Nx × 1 × time\nres.pos_smoother     # Prob(s_t | y_{1...T})\nres.pos_filter       # Prob(s_t | y_{1...t}), only if `save_filter = true` was used\nres.residence_dist   # 1/T Σ Prob(s_t | y_{1...T})\nres.trajectories     # Vector of trajectories sampled from Prob(s_{1...T} | y_{1...T})\nres.log_p            # Prob(y_t)\nres.tsave            # time points","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The result of the smoother res.pos_smoother can be visualized:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"<img src=\"../assets/smoothing_animated.gif\" style=\"width: 75%; height: auto;\" />","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Note, the code for visualization is not part of Wahoo.","category":"page"}]
}
